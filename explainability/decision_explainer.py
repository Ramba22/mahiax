"""
Decision Explainer for MAHIA-X
Provides explanations for model decisions and intelligent suggestions
"""

import json
from typing import Dict, Any, List, Optional, Tuple
from collections import defaultdict
import time
from datetime import datetime

class DecisionExplainer:
    """Explains model decisions and reasoning"""
    
    def __init__(self):
        self.explanation_templates = {
            'classification': "This classification was made based on {features} with confidence {confidence}.",
            'recommendation': "This recommendation was generated considering {factors} and your preferences.",
            'prediction': "This prediction is based on {data_points} and historical patterns.",
            'response': "This response was generated by analyzing {features} and applying {knowledge}."
        }
        
        self.feature_importance_tracker = defaultdict(lambda: defaultdict(float))
        
    def generate_explanation(self, decision_type: str, decision_data: Dict[str, Any]) -> str:
        """Generate explanation for a decision"""
        template = self.explanation_templates.get(decision_type, 
                                               "This decision was made based on the analysis of relevant factors.")
        
        # Extract key information from decision data
        context = self._extract_context(decision_data)
        
        # Format explanation
        explanation = template.format(**context)
        return explanation
        
    def _extract_context(self, decision_data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract context information from decision data"""
        context = {}
        
        # Extract features used in decision
        features = decision_data.get('features', [])
        if features:
            context['features'] = ', '.join(features[:3]) + (' and others' if len(features) > 3 else '')
        else:
            context['features'] = 'relevant input data'
            
        # Extract confidence level
        context['confidence'] = f"{decision_data.get('confidence', 0.5) * 100:.1f}%"
        
        # Extract factors
        factors = decision_data.get('factors', [])
        if factors:
            context['factors'] = ', '.join(factors[:3]) + (' and other factors' if len(factors) > 3 else '')
        else:
            context['factors'] = 'multiple considerations'
            
        # Extract data points
        data_points = decision_data.get('data_points', [])
        if data_points:
            context['data_points'] = f"{len(data_points)} data points"
        else:
            context['data_points'] = 'available data'
            
        # Extract knowledge sources
        knowledge = decision_data.get('knowledge_sources', [])
        if knowledge:
            context['knowledge'] = ', '.join(knowledge[:2]) + (' and other sources' if len(knowledge) > 2 else '')
        else:
            context['knowledge'] = 'domain knowledge'
            
        return context
        
    def track_feature_importance(self, feature_name: str, importance_score: float, 
                               decision_id: Optional[str] = None):
        """Track feature importance for explainability"""
        if decision_id is None:
            decision_id = f"decision_{int(time.time() * 1000)}"
            
        self.feature_importance_tracker[decision_id][feature_name] = importance_score
        
    def get_feature_importance_report(self, decision_id: Optional[str] = None) -> Dict[str, Any]:
        """Get feature importance report"""
        if decision_id:
            # Return specific decision report
            if decision_id in self.feature_importance_tracker:
                features = dict(self.feature_importance_tracker[decision_id])
                sorted_features = sorted(features.items(), key=lambda x: x[1], reverse=True)
                return {
                    'decision_id': decision_id,
                    'feature_importance': dict(sorted_features),
                    'total_features': len(features)
                }
            else:
                return {'error': 'Decision ID not found'}
        else:
            # Return overall report
            all_features = defaultdict(float)
            feature_counts = defaultdict(int)
            
            for decision_features in self.feature_importance_tracker.values():
                for feature, importance in decision_features.items():
                    all_features[feature] += importance
                    feature_counts[feature] += 1
                    
            # Calculate average importance
            avg_importance = {}
            for feature in all_features:
                avg_importance[feature] = all_features[feature] / feature_counts[feature]
                
            sorted_features = sorted(avg_importance.items(), key=lambda x: x[1], reverse=True)
            
            return {
                'overall_feature_importance': dict(sorted_features[:20]),  # Top 20 features
                'total_decisions': len(self.feature_importance_tracker),
                'total_features': len(all_features)
            }

class IntelligentSuggestionEngine:
    """Generates intelligent suggestions based on context and user behavior"""
    
    def __init__(self):
        self.suggestion_templates = {
            'follow_up': "You might also want to know about {topic}.",
            'deep_dive': "Would you like me to elaborate on {aspect}?",
            'related': "This relates to {related_topic} which you might find interesting.",
            'clarification': "Should I clarify anything about {subject}?",
            'extension': "Building on this, we could explore {extension}."
        }
        
        self.user_behavior_history = defaultdict(list)
        self.context_patterns = {}
        
    def generate_suggestions(self, current_context: Dict[str, Any], 
                           user_id: Optional[str] = None) -> List[Dict[str, Any]]:
        """Generate intelligent suggestions based on context"""
        suggestions = []
        
        # Extract key elements from context
        query = current_context.get('query', '').lower()
        topic = current_context.get('topic', '')
        response = current_context.get('response', '')
        
        # Generate context-based suggestions
        context_suggestions = self._generate_context_suggestions(query, topic, response)
        suggestions.extend(context_suggestions)
        
        # Generate user-based suggestions if user_id provided
        if user_id:
            user_suggestions = self._generate_user_suggestions(user_id, current_context)
            suggestions.extend(user_suggestions)
            
        # Add timestamps and unique IDs
        for i, suggestion in enumerate(suggestions):
            suggestion['id'] = f"suggestion_{int(time.time() * 1000)}_{i}"
            suggestion['timestamp'] = datetime.now().isoformat()
            
        return suggestions
        
    def _generate_context_suggestions(self, query: str, topic: str, 
                                    response: str) -> List[Dict[str, Any]]:
        """Generate suggestions based on current context"""
        suggestions = []
        
        # Topic-based suggestions
        if 'python' in query or 'code' in query:
            suggestions.append({
                'type': 'follow_up',
                'suggestion': self.suggestion_templates['follow_up'].format(
                    topic='Python best practices'
                ),
                'confidence': 0.8,
                'trigger': 'programming_query'
            })
            
        if 'machine learning' in query or 'ml' in query:
            suggestions.append({
                'type': 'deep_dive',
                'suggestion': self.suggestion_templates['deep_dive'].format(
                    aspect='specific algorithms'
                ),
                'confidence': 0.7,
                'trigger': 'ml_query'
            })
            
        # Response-based suggestions
        if len(response.split()) > 100:  # Long response
            suggestions.append({
                'type': 'clarification',
                'suggestion': self.suggestion_templates['clarification'].format(
                    subject='any part of this explanation'
                ),
                'confidence': 0.6,
                'trigger': 'long_response'
            })
            
        return suggestions
        
    def _generate_user_suggestions(self, user_id: str, 
                                 current_context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate suggestions based on user behavior"""
        suggestions = []
        
        # Get user history
        user_history = self.user_behavior_history.get(user_id, [])
        
        if len(user_history) > 2:
            # Analyze patterns in user behavior
            recent_queries = [entry.get('query', '') for entry in user_history[-3:]]
            
            # If user asks related questions, suggest deeper exploration
            if self._are_queries_related(recent_queries):
                suggestions.append({
                    'type': 'extension',
                    'suggestion': self.suggestion_templates['extension'].format(
                        extension='more advanced concepts in this area'
                    ),
                    'confidence': 0.7,
                    'trigger': 'related_queries_pattern'
                })
                
        return suggestions
        
    def _are_queries_related(self, queries: List[str]) -> bool:
        """Check if queries are related"""
        if len(queries) < 2:
            return False
            
        # Simple keyword overlap check
        query_words = [set(q.lower().split()) for q in queries]
        common_words = set.intersection(*query_words)
        
        return len(common_words) > 1
        
    def record_user_interaction(self, user_id: str, interaction_data: Dict[str, Any]):
        """Record user interaction for learning"""
        if user_id:
            interaction_data['timestamp'] = datetime.now().isoformat()
            self.user_behavior_history[user_id].append(interaction_data)
            
            # Keep history manageable
            if len(self.user_behavior_history[user_id]) > 50:
                self.user_behavior_history[user_id] = self.user_behavior_history[user_id][-25:]
                
    def get_user_pattern_report(self, user_id: str) -> Dict[str, Any]:
        """Get report on user interaction patterns"""
        if user_id not in self.user_behavior_history:
            return {'error': 'No history for user'}
            
        history = self.user_behavior_history[user_id]
        
        # Analyze patterns
        topics = defaultdict(int)
        interaction_types = defaultdict(int)
        
        for entry in history:
            # Extract topics (simplified)
            query = entry.get('query', '').lower()
            if 'python' in query:
                topics['programming'] += 1
            if 'machine learning' in query or 'ml' in query:
                topics['ml'] in query  # This is a bug, let me fix it
                topics['ml'] += 1
            if 'data' in query:
                topics['data'] += 1
                
            # Interaction types
            interaction_types[entry.get('type', 'unknown')] += 1
            
        return {
            'user_id': user_id,
            'total_interactions': len(history),
            'preferred_topics': dict(sorted(topics.items(), key=lambda x: x[1], reverse=True)),
            'interaction_types': dict(interaction_types),
            'last_interaction': history[-1]['timestamp'] if history else None
        }

class RealTimeOptimizer:
    """Optimizes model parameters in real-time based on performance feedback"""
    
    def __init__(self):
        self.performance_metrics = defaultdict(list)
        self.parameter_adjustments = []
        self.optimization_rules = []
        
    def register_optimization_rule(self, condition_func, adjustment_func, parameter_name: str):
        """Register an optimization rule"""
        self.optimization_rules.append({
            'condition': condition_func,
            'adjustment': adjustment_func,
            'parameter': parameter_name
        })
        
    def update_performance_metric(self, metric_name: str, value: float, 
                                context: Optional[Dict[str, Any]] = None):
        """Update performance metric"""
        self.performance_metrics[metric_name].append({
            'value': value,
            'timestamp': datetime.now().isoformat(),
            'context': context or {}
        })
        
        # Keep metric history manageable
        if len(self.performance_metrics[metric_name]) > 100:
            self.performance_metrics[metric_name] = self.performance_metrics[metric_name][-50:]
            
    def check_and_optimize(self) -> List[Dict[str, Any]]:
        """Check conditions and apply optimizations"""
        adjustments = []
        
        # Calculate recent averages for metrics
        recent_metrics = {}
        for metric_name, values in self.performance_metrics.items():
            if values:
                recent_values = [v['value'] for v in values[-10:]]  # Last 10 values
                recent_metrics[metric_name] = sum(recent_values) / len(recent_values)
                
        # Check optimization rules
        for rule in self.optimization_rules:
            try:
                if rule['condition'](recent_metrics):
                    adjustment = rule['adjustment'](recent_metrics)
                    if adjustment != 0:  # Only record non-zero adjustments
                        adjustment_record = {
                            'parameter': rule['parameter'],
                            'adjustment': adjustment,
                            'reason': f"Based on {list(recent_metrics.keys())}",
                            'timestamp': datetime.now().isoformat()
                        }
                        adjustments.append(adjustment_record)
                        self.parameter_adjustments.append(adjustment_record)
            except Exception as e:
                print(f"Error applying optimization rule: {e}")
                
        return adjustments
        
    def get_optimization_report(self) -> Dict[str, Any]:
        """Get optimization report"""
        return {
            'metrics_tracked': list(self.performance_metrics.keys()),
            'total_adjustments': len(self.parameter_adjustments),
            'recent_adjustments': self.parameter_adjustments[-10:],  # Last 10 adjustments
            'performance_trends': self._calculate_trends()
        }
        
    def _calculate_trends(self) -> Dict[str, str]:
        """Calculate performance trends"""
        trends = {}
        
        for metric_name, values in self.performance_metrics.items():
            if len(values) >= 5:
                recent = [v['value'] for v in values[-5:]]
                older = [v['value'] for v in values[-10:-5]]
                
                recent_avg = sum(recent) / len(recent)
                older_avg = sum(older) / len(older) if older else recent_avg
                
                if recent_avg > older_avg * 1.1:
                    trends[metric_name] = 'improving'
                elif recent_avg < older_avg * 0.9:
                    trends[metric_name] = 'declining'
                else:
                    trends[metric_name] = 'stable'
            else:
                trends[metric_name] = 'insufficient_data'
                
        return trends

# Example usage
if __name__ == "__main__":
    # Initialize components
    explainer = DecisionExplainer()
    suggestion_engine = IntelligentSuggestionEngine()
    optimizer = RealTimeOptimizer()
    
    # Example decision explanation
    decision_data = {
        'features': ['feature1', 'feature2', 'feature3'],
        'confidence': 0.85,
        'factors': ['accuracy', 'relevance', 'timeliness'],
        'data_points': ['point1', 'point2'],
        'knowledge_sources': ['database', 'api']
    }
    
    explanation = explainer.generate_explanation('classification', decision_data)
    print("Explanation:", explanation)
    
    # Track feature importance
    explainer.track_feature_importance('feature1', 0.9, 'decision_001')
    explainer.track_feature_importance('feature2', 0.7, 'decision_001')
    
    # Get feature importance report
    feature_report = explainer.get_feature_importance_report()
    print("Feature Report:", feature_report)
    
    # Generate suggestions
    context = {
        'query': 'How to implement machine learning in Python?',
        'topic': 'machine learning',
        'response': 'Machine learning in Python can be implemented using scikit-learn...'
    }
    
    suggestions = suggestion_engine.generate_suggestions(context, 'user_123')
    print("Suggestions:", suggestions)
    
    # Record user interaction
    suggestion_engine.record_user_interaction('user_123', {
        'query': 'How to implement machine learning in Python?',
        'type': 'technical_question'
    })
    
    # Update performance metrics
    optimizer.update_performance_metric('response_time', 0.5)
    optimizer.update_performance_metric('accuracy', 0.92)
    
    # Check for optimizations
    adjustments = optimizer.check_and_optimize()
    print("Adjustments:", adjustments)
    
    # Get optimization report
    opt_report = optimizer.get_optimization_report()
    print("Optimization Report:", opt_report)